1. Получить информацию о всех гномах, которые входят в какой-либо отряд, вместе с информацией об их отрядах.

	Рефлексия:
	Решения совпадают. Различаются возвращаемые поля, но поскольку они не были оговорены в условии это не является критичным.

	В образце понравилась запись в столбик с использованием отступов. CamelCase запись переменных. Используется JOIN у меня INNER JOIN, что синонимы.


2. Найти всех гномов с профессией "miner", которые не состоят ни в одном отряде.
   
   Рефлексия:
   Ответы совпадают. Есть отличия в оформлении.
   
3. Получить все задачи с наивысшим приоритетом, которые находятся в статусе "pending"
   
  Рефлексия:
	У меня максимальный приоритет считается по всем задачам, что не верно. Может привести к ситуации, когда надо получить "pending" с наивысшим приоритетом, в случае если с наивысшим приоритетом уже "in_progress" или "completed" и он выше, чем у "pending", то запрос не будет ничего возвращать.


4. Для каждого гнома, который владеет хотя бы одним предметом, получить количество предметов, которыми он владеет.
   
  Рефлексия:
  Ответы отличаются, так как я считал что если предмет общий, то он принадлежит всем гномам. И соответственно добавлял его к количеству предметов которыми владеет каждый гном, затем через .
   
5. Получить список всех отрядов и количество гномов в каждом отряде. Также включите в выдачу отряды без гномов.
   
  Рефлексия:
  Решения совпадают. 
   
6. Получить список профессий с наибольшим количеством незавершённых задач ("pending" и "in_progress") у гномов этих профессий.
      
  Рефлексия:
  В образце возвращается полный список профессий отсортированных по убыванию количества незавершённых задач. Профессии с наибольшим количеством незавершённых задач можно будет получить позднее программно.

  У меня текст запроса содержит больше строк, но возвращает только профессии с наибольшим количеством незавершённых задач. Предполагаю, он лучше соответствует условию задачи. 
    
  В эталонном решении для подсчета количества используется `COUNT(I.item_id)` у меня `COUNT(*)` что в случае внутреннего соединения дает одинаковый результат.


7. Для каждого типа предметов узнать средний возраст гномов, владеющих этими предметами.
  
  Рефлексия:
  Решения отличаются. 
  Ситуация аналогичная как в задаче 4. У меня если предмет общий, то считаю что каждый гном им владеет. И считают среднее исходя из этого. 

  В эталонном решении если, для гном например владеет двумя разными предметами одного типа, тогда при расчете среднего он будет посчитан дважды. Что предполагаю неверно.


8. Найти всех гномов старше среднего возраста (по всем гномам в базе), которые не владеют никакими предметами.
   
  Рефлексия:
  Решение правильное.

  Использую левое соединение и условие `item_id is NULL` для того, чтобы отобрать гномов, которые не владеют предметами. В эталонном решении используется `dwarf_id NOT IN (SELECT owner_id FROM Items)`.
  Свой вариант выбрал, предполагая что левое соединение с отбором работает быстрее, чем поиск на вхождение. 
