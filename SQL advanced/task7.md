Рефлексия:

1. Сравнение решений.

Задание 2. Решение совпадает.

Задание 3. Вместо таблицы workshop_products использую workshop_materials, предположив что если `NOT wm.is_input` то это продукты. Что неверно.

Задание 4. Решение совпадает.


2. При всей сложности описываемой ситуации данными, запросы оказалось писать не сложно. Оформляя при этом отступами.

3. В этот раз решил строки обернуть `JSON_BUILD_OBJECT`, хотя до конца не был уверен в этом решении. В эталонном решении этого нет. Механизм, который будет создавать REST API, сделает это лучше.

4. Как вариант можно использовать 'COALESCE'. 
Например так:

``` sql

...

'equipment_ids', COALESCE(
					(
						SELECT JSON_AGG(se.equipment_id)
						FROM SQUAD_EQUIPMENT se
						WHERE se.squad_id = ms.squad_id
					),
						'[]'::json
				),
				
...

```
В ответах был бы результат вида `'equipment_ids': []`, а не `'equipment_ids': NULL` как сейчас в PostgreSQL.

