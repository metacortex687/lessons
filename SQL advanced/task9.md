Рефлексия:

1. В эталонном решении используется CTE (Common Table Expression), с помощью команды WITH создаются общие таблицы. У меня есть запрос, к которому через левое соединение присоединяю подзапросы, при этом в присоединяемых таблицах группирую по expedition_id, что исключает «задвоение» записей после левого соединения.

2. У меня гораздо больше используется GROUP BY. В эталонном решении два «подзапроса»: expedition_stats и skills_progression. В expedition_stats сгруппированы данные, которые можно получить одним запросом. skills_progression — более сложный запрос.
   У меня для каждого значения отдельный подзапрос, что, с одной стороны, если использовать отступы, позволяет не сильно задумываясь, используя отступы, расширять запрос практически неограниченно. С другой стороны, из-за множественных GROUP BY он менее оптимизирован.

3. Получение соотношения выживших участников к общему числу.  'survival_rate'.
   Использую приведение булева типа к числу и вычисление среднего от этого числа.
   `AVG(survived::int)` - это на мой взгляд удачно.
   С другой стороны у меня доля участников, которую не перевожу в проценты. Что ошибка, не соответствует тестовому примеру.  Но при этом легко исправимая.
   В эталонном решении используется приведение целых к «::DECIMAL», чтобы не получилось целочисленное деление.

4. Получение ценности найденных артефактов.  'artifacts_value'
   И в эталонном, и у меня используется COALESCE, чтобы, если нет значения, оно NULL, то числовое значение должно быть 0.

5. Получение количество обнаруженных новых мест.
   Решение почти совпадает с эталонным, только при подсчете количества не использую 'DISTINCT' предполагая что не будет одинаковых site_id в рамках одной экспедиции.
6. Успешность встреч с существами. 'overall_success_score'.

	Также, как и в эталонном решении, предполагаю, что 'outcome' — это статус в виде строки. Предполагаю, что может быть несколько строк, поэтому использую IN.
```sql
AVG(
					CASE
						WHEN outcome IN ('GOOD') then 1
						ELSE 0
					END
				) as encounter_success_rate
```

7. Опыт, полученный участниками. 'skill_improvement'
У меня допущение, что любая запись в `dwarf_skills` по тем гномам в отряде и за время экспедиции приводит к повышению уровня.
Если есть понижения уровня или дублирование записей, тогда у меня ответ будет неверный.

Плюс к этому делаю отбор, что должны быть заполнены.

8. Длительность экспедиции. expedition_duration
  Предположил что  departure_date и return_date это целые числа. Например номер хода в игре. Поэтому просто отнял одно от другого.
  При этом в итоговой выборке дополнительная проверка/отбор что departure_date и return_date не NULL.
  
9. Рейтинг экспедиции. overall_success_score
   У меня данные для расчета формулы получаются в подзапросе.
   В эталонном примере используется NULLIF, поскольку используется деление, чтобы не было ошибки деления на 0. У меня в формуле нет деления.


**Итоговая рефлексия:**

В целом у меня запрос рабочий, есть недочеты. И есть допущения отличные от тех что в основе эталонного решения.

Главное отличие, что у меня каждое значение получается в отдельном подзапросе. И он соединяется через левое соединение. И через промежуточный запрос где обрабатываю NULL с помощью COALESCE, значения выходят для расчёта overall_success_score.

С использованием отступов, мой запрос позволяет сделать запрос практически любого размера.

В эталонном решении, более простые значения группируются в одном запросе. Более сложные значения считаются в другом запросе. Используется меньше GROUP BY. Более оптимизирован. Плюс отражено сходство многих получаемых значений, то что они получаются в одном запросе.

  