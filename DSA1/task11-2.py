# Раздел: 10. Фильтр Блюма

# Задача 4 
# Реализовать слияние фильтров Блюма
# Класс: BloomFilter2 
# Метод: self.add_filter
# Вычислительная сложность: O(1)
# Решение:
# Через битовую операцию ИЛИ

# Задача 5 
# Реализовать удаление в фильтре Блюма
# Обоснование невозможности хорошего решения:
# а) Сделать счётчики добавленных и удалённых элементов — но это уже будет не фильтр Блюма.
# б) Сделать фильтр для хранения удалённых элементов. И если элемент находится и в основном фильтре, 
# и в фильтре удалённых — тогда считать, что его уже нет, то-есть удаляли. 
# Данное решение не подходит, поскольку фильтр Блюма может давать ложно положительные ответы, 
# но не должен давать ложно отрицательных. Если использовать для исключения фильтр с удалёнными значениями, 
# он может дать ложно положительный ответ — и на выходе получится ложно отрицательный итог. 
# Таким образом нарушается главное свойство фильтра Блюма: можно допускать ложноположительные ответы, 
# но нельзя допускать ложноотрицательных.

# Задача 6 
# Реализовать восстановление значений, помещённых в фильтр
# Алгоритмическая сложность: сравнима с O(n!^2) или больше, где n — длина фильтра
# Решение: не реализовывал
# Возможный вариант решения:
# Собираем различные сочетания битов — примерно n! вариантов.
# Они могут быть как из первой хэш-функции, так и из второй. Получаем n!^2 вариантов.
# На выходе — наборы пар чисел (hash_1, hash_2).
# Далее нужно подобрать такие строки, что:
# 17^l * s_1 + 17^(l-1) * s_2 + ... + s_l = 17*n + hash_1
# 223^l * s_1 + 223^(l-1) * s_2 + ... + s_l = 223*m + hash_2
# где l — длина строки, s_1 ... s_l — коды символов, n и m — произвольные.
# При этом s_1, ..., s_l — целые в диапазоне кодов символов.
# Можно наложить ограничения на n, m и максимальную длину слова и попытаться решить перебором.

from __future__ import annotations

class BloomFilter2:

    def __init__(self, f_len):
        self.filter_len = f_len
        self.filter = 0

    def add_filter(self, filter2 : BloomFilter2):
        self.filter |= filter2.filter

        


    def hash1(self, str1):
        _mask = (1 << self.filter_len) - 1
        _hash = 0
        # 17
        for c in str1:
            _hash = _hash*17 + ord(c)
            _hash &= _mask
        return _hash


    def hash2(self, str1):
        _mask = (1 << self.filter_len) - 1
        _hash = 0
        # 223
        for c in str1:
            _hash = _hash*223 + ord(c)
            _hash &= _mask
        return _hash

    def add(self, str1):
        self.filter |= self.hash1(str1)
        self.filter |= self.hash1(str1)


    def is_value(self, str1) -> bool:
        
        _hash1 = self.hash1(str1)
        _hash2 = self.hash1(str1)
        
        return (_hash1 & self.filter == _hash1) and  (_hash2 & self.filter == _hash2)
        