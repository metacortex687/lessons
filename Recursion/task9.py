#9 (доп). Генерация всех корректных сбалансированных комбинаций круглых скобок (параметр -- количество открывающих скобок).
# тесты → ./task8_test.py: https://github.com/metacortex687/lessons/blob/main/Recursion/task9_test.py

#Расчет алгоритмической сложности: буду считать алгоритмическую сложность от количества элементов в итоговой выборке. 
# Если надо подсчитать алгоритмическую сложность от длины  последовательности, то подставляется  формула для расчета числа комбинаций. 
# Что немного странно, так алгоритмическая  сложность, думаю, предполагает влияние на неё  оптимизацией алгоритмов. 
# 
# Функцию кэширования для упрощения буду считать идеальной работающей за O(1), у меня словарь, но вполне можно реализовать 
# через доступ по индексу.
# Для получения итоговой выборки размера n делается n операций и она имеет коолличество пар count_pairs, 
# но при этом результат использует наборы последовательностей которые count_pairs-1, count_pairs-2, ... , 1
# Колличество комбинаций  на меньших count_pairs убывает примерно экспоненциально.

# Алгоритмическая сложность: ~ O(n * log n), где n — количество последовательностей в итоговой выборке.

#Решение: любую последовательность сбалансированных скобок можно представить в виде "seq = (seq1)seq2" 
# где seq1 и seq2 - это или пустая последовательность или последовательность сбалансированных скобок
# таким образом перебирая все возможные seq1 и seq2, так чтобы  len(seq) = len(seq1) + len(seq2) + 1 
# я переберу все возможные seq.
# Отсутствие задвоений в списке элементов seq, обеспечивается уникальностью в своих списках seq1 и seq2
#
# Для оптимизации использую, кэширование реализованное классом "Cache", в этом случае не надо повторно 
# пересчитывать уже посчитанный ранее результат.

from itertools import product

class Cache:
    def __init__(self, func):
        self.func = func
        self._memo = {}

    def __call__(self, count_pairs):
        if count_pairs not in self._memo:
            self._memo[count_pairs] = self.func(count_pairs)
        return self._memo[count_pairs]

@Cache
def generate_balanced_parentheses(count_pairs: int) -> list[str]:
    if count_pairs == 0:
        return [""]

    if count_pairs == 1:
        return ["()"]
             
    result = []
    for i in range(0,count_pairs):

        left = [f"({v})" for v in generate_balanced_parentheses(i)]
        right = generate_balanced_parentheses(count_pairs-i-1)

        result.extend(''.join(p) for p in product(left,right))

    return result



 


 


