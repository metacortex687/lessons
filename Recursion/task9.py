#9 (доп). Генерация всех корректных сбалансированных комбинаций круглых скобок (параметр -- количество открывающих скобок).

#Расчет алгоритмической сложности: буду считать алгоритмическую сложность от количества элементов в итоговой выборке. 
# Если надо подсчитать алгоритмическую сложность от длины  последовательности, то подставляется  формула для расчета комбинаций. 
# Что немного странно, так алгоритмическая  сложность, думаю, предполагает влияние на неё  оптимизацией алгоритмов. 
# 
# Функцию кэширования для упрощения буду считать идеальной работающей за O(1), у меня словарь, но вполне можно реализовать 
# через доступ по индексу.
# Для получения итоговой выборки делается n операций, при этом она использует для расчета последовательности для n-1, n-2,.. , 1 
# Получается сумма арифметической прогрессии, то есть квадрат.

# Алгоритмическая сложность: ~ O(n^2), где n — количество комбинаций  в итоговой выборке.

#Решение: любую последовательность сбалансированных скобок можно представить в виде "seq = (seq1)seq2" 
# где seq1 и seq2 - это или пустая последовательность или последовательность сбалансированных скобок
# таким образом перебирая все возможные seq1 и seq2, так чтобы  len(seq) = len(seq1) + len(seq2) + 1 
# я переберу все возможные seq.
# Отсутствие задвоений в списке элементов seq, обеспечивается уникальностью в своих списках seq1 и seq2
#
# Для оптимизации использую, кэширование реализованное классом "Сache", в этом случае не надо повторно 
# пересчитывать уже посчитанный ранее результат.

from itertools import product

class Сache:
    def __init__(self, func):
        self.func = func
        self._memo = {}

    def __call__(self, count_pairs):
        if count_pairs not in self._memo:
            self._memo[count_pairs] = self.func(count_pairs)
        return self._memo[count_pairs]

@Сache
def generate_balanced_parentheses(count_pairs: int) -> list[str]:
    if count_pairs == 0:
        return [""]

    if count_pairs == 1:
        return ["()"]
             
    result = []
    for i in range(0,count_pairs):

        left = [f"({v})" for v in generate_balanced_parentheses(i)]
        right = generate_balanced_parentheses(count_pairs-i-1)

        result.extend(''.join(p) for p in product(left,right))

    return result



 


 


